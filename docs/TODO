1) Optimize REST-API endpoint /config/devices and /config/devices/<serial>. Complete JSON structure tends to be rebuild even after small config change.
   Have UI use this where appropiate. 

2) DONE: restapi.c, check if we can get rid of device_name_from_type(), feels misplaced here.

3) DONE: AUX configuration not working as it shares the channel id with R2.

4) Performance friendly debug output of JSON objects. That is do json_dump() only if the loglevel matches.

5) DONE: memory leak, should call tty_clode() instead of close(router->fd)

6) Check struct mh_control, set_mode, used for what? Can be removed?

7) DONE: Make submit_cmd() and derived functions as void return. Currently it returns -1 on failure, but the caller does not always check this. 
   Instead submit_cmd() should call the callbacks even when it fails, so that the caller can react to this. This way error handling has 
   to happen in one place, the callbacks.
   After some reading, even if sumit_cmd() immediately fails, the callback should be called async, that is from the main event loop. See
   ev_idle.

8) Check renamed functions in libev 4, e.g. ev_unloop() -> ev_break(). We still seem to use old ones.

9) Check signal handler in main.c.  

10) rigctld control, like start/stop with mhuxd and/or keyer becoming online / offline. rigctld could then also be used my mhuxd to track 
   the rig mode and apply it to the keyer accordingly.

11) DONE: If with new json implementation, if VSP can't be created, it gets removed from config. That is, it wouldn't be 
   saved when mhuxd terminates, since it wasn't created. We don't hold a config shadow copy anymore.

12) dmgr_set_device_added_cb(), quick hack, should manage a callback list as everyone else.

13) MK2R(+) Small UI issue, when we change baud radio on both radios, click apply for radio 1, baud rate for radio 2 
   resets to original value.

14) When staring mhuxd with no config, keyer off, then turn on keyer, it doesn't get reactively added to the keyer list.

15) Check this, when not setting high baud rate, we may get EPERM

The tcsetattr function with the TCSANOW action translates to the TCSETS ioctl call on Linux. Your con_vsp.c implementation already handles TCSETS (as well as TCSETSW for TCSADRAIN and TCSETSF for TCSAFLUSH), so the plumbing for TCSANOW is present.

The issue is that TCSETS fails with EPERM (Operation not permitted) because the requested baud rate (115200) is being rejected by termios_baud_rate().

The file linux_termios.c currently excludes baud rates of 115200 and higher unless NO_MICRO_HAM is defined. Since this macro is not defined in your build configuration, these standard high baud rates are treated as unsupported, causing the EPERM error in con_vsp.c.

I will patch linux_termios.c to enable support for these baud rates.

### core-refactor

CR-01) Define fd ownership contract in code comments and docs:
       - each fd has exactly one closer
       - non-owners can request teardown but never close directly

CR-02) Add shared endpoint state enum + helpers (`OPEN`, `DRAINING`, `FAILED`, `CLOSED`).

CR-03) Add small nonblocking I/O helpers (read/write result normalization):
       - `>0` progress
       - `==0` EOF/no-progress policy
       - `EAGAIN`/`EWOULDBLOCK` retry
       - other `<0` hard error

CR-04) Add watcher lifecycle wrappers:
       - guarded `start` (valid fd + allowed state)
       - idempotent `stop`

CR-05) Convert `con_tcp.c` to shared helpers first (no behavior change intended).

CR-06) Unify `con_tcp` teardown into one idempotent close path.

CR-07) Convert `con_vsp.c` to state-gated watcher re-arm logic and shared teardown helpers.

CR-08) Align `mhrouter.c` endpoint teardown to ownership wrappers only.

CR-09) Restrict `conmgr.c` to orchestration only (no closing router-owned fds).

CR-10) Add debug/invariant checks (gated by loglevel/debug build):
       - watcher on invalid fd
       - invalid state transition
       - close by non-owner
       - callback after terminal state

CR-11) Fault-injection validation pass:
       - forced connector read/write errors
       - repeated teardown calls
       - verify no libev invalid-fd assert

CR-12) Final cleanup:
       - remove obsolete duplicate error handling paths
       - document final architecture in `docs/core-refactor.md`

### CR-11 execution log template

Date:
Build:
Config:
Scope:

Scenario A (VSP forced CUSE read failure): PASS/FAIL
- Notes:

Scenario B (TCP remote close churn): PASS/FAIL
- Notes:

Scenario C (full destroy path): PASS/FAIL
- Notes:

Scenario D (repeat create/destroy cycles): PASS/FAIL
- Notes:

Regressions observed:
Follow-up actions:

### CR-11 latest run (example)

Date: 2026-02-17
Build: make -C build -j4 (PASS)
Config: baseline (VSP + TCP + PTT mapped)
Scope: CR-01..CR-04 in-progress validation

Scenario A (VSP forced CUSE read failure): PASS
- Notes: connector entered terminal state, no watcher rearm observed.

Scenario B (TCP remote close churn): PASS
- Notes: repeated connect/disconnect stable; no stale fd activity.

Scenario C (full destroy path): PASS
- Notes: no duplicate close for aliased VSP fds (`fd_ptt == fd_data`).

Scenario D (repeat create/destroy cycles): PASS
- Notes: 10 cycles, no invalid-fd assert.

Regressions observed:
- none

Follow-up actions:
- continue CR-02/CR-04 rollout to remaining callback edges
- keep running CR-11 after each lifecycle-related patch

### CR-11 latest run (2026-02-17, CR-07 validation)

Date: 2026-02-17
Build: make -C build -j4 (PASS)
Config: /usr/local/mhuxd/var/lib/mhuxd-state.json (demo run `-2`, connectors mapped to `M3_DEMO_MK3_1`)
Scope: CR-07 con_vsp watcher/state/teardown refactor validation

Scenario A (VSP forced CUSE read failure): NOT EXECUTED
- Notes: VSP path was exercised (`cat1` open/TCSETS/release), but no explicit CUSE fault was injected in this run.

Scenario B (TCP remote close churn): NOT EXECUTED
- Notes: TCP connector created; churn sequence not driven in this run.

Scenario C (full destroy path): PASS
- Notes: valgrind run + SIGTERM shutdown showed single close sequence for `cat1`, `wk`, `ptt1`, `fsk1`, and TCP connector; no `epoll_modify ... invalid fd` and no valgrind "already closed" fd diagnostics observed.

Scenario D (repeat create/destroy cycles): NOT EXECUTED
- Notes: single create/destroy cycle only.

Regressions observed:
- none in CR-07 shutdown path under this run.

Follow-up actions:
- Add a dedicated fault-injection toggle for Scenario A (forced CUSE read failure) and rerun under valgrind.
- Run Scenario B churn and Scenario D multi-cycle pass with the same config.

### CR-11 latest run (2026-02-17, deterministic Scenario A)

Date: 2026-02-17
Build: make -C build -j4 (PASS)
Config: /usr/local/mhuxd/var/lib/mhuxd-state.json + env `MHUXD_VSP_FORCE_CUSE_FAIL_ONCE=1`
Scope: CR-07 validation with explicit VSP CUSE-read fault injection

Scenario A (VSP forced CUSE read failure): PASS
- Notes: deterministic injection fired on `cat1`, `wk`, `ptt1`, `fsk1`; connectors entered terminal/fail path; no `epoll_modify ... invalid fd` observed.

Scenario B (TCP remote close churn): NOT EXECUTED
- Notes: TCP connector created, but churn sequence not exercised in this run.

Scenario C (full destroy path): PASS
- Notes: SIGTERM shutdown completed with connector close logs; valgrind showed no fd double-close diagnostics.

Scenario D (repeat create/destroy cycles): NOT EXECUTED
- Notes: single cycle only.

Regressions observed:
- none in fd/watcher safety paths; router emitted `mhr_rem_* fd not found` warnings during forced-fail teardown sequence.

Follow-up actions:
- Run Scenario B and Scenario D next.
- Triage whether `mhr_rem_* fd not found` should be debug-level in forced-failure paths.

### CR-11 latest run (2026-02-18, Scenario B + D)

Date: 2026-02-18
Build: make -C build -j4 (PASS, from prior step)
Config: /usr/local/mhuxd/var/lib/mhuxd-state.json (demo `-2`)
Scope: Execute remaining Scenario B and Scenario D checks after deterministic Scenario A/C pass

Scenario A (VSP forced CUSE read failure): PASS (covered in previous run)
- Notes: deterministic env-toggle run already validated.

Scenario B (TCP remote close churn): PASS
- Notes: valgrind run on `localhost:5156` with repeated `nc` connect/disconnect to `127.0.0.1:6000` showed stable incoming/closed pairs and clean shutdown.

Scenario C (full destroy path): PASS
- Notes: present in this run as SIGTERM shutdown path; connectors closed once, no invalid-fd symptoms observed.

Scenario D (repeat create/destroy cycles): PASS
- Notes: 10/10 cycles completed (`CYCLE_1_DONE`..`CYCLE_10_DONE`) across unique web ports (`5161`..`5170`), including one injected-fault cycle (`i=5`).

Regressions observed:
- no `invalid fd` / `already closed` lines observed in Scenario B/D logs.
- `mhr_rem_* fd not found` appeared in forced-failure teardown (8 lines in Scenario D log), consistent with earlier observation.

Follow-up actions:
- Optional: downgrade forced-failure `mhr_rem_* fd not found` to debug-level if we treat it as expected during already-removed endpoints.
- Continue CR-10 invariant tightening (especially callback-after-terminal and router teardown diagnostics).
